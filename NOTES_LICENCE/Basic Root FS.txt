CREDIT:  http://www.tldp.org/HOWTO/Bootdisk-HOWTO/buildroot.html


    /dev -- Device files, required to perform I/O

    /proc -- Directory stub required by the proc filesystem

    /etc -- System configuration files

    /sbin -- Critical system binaries

    /bin -- Essential binaries considered part of the system

    /lib -- Shared libraries to provide run-time support

    /mnt -- A mount point for maintenance on other disks

    /usr -- Additional utilities and applications



Three of these directories will be empty on the root filesystem, so they only need to be created with mkdir.
The /proc directory is basically a stub under which the proc filesystem is placed. The directories /mnt and /usr
are only mount points for use after the boot/root system is running. Hence again, these directories only need to be created.


4.3.1. /dev
A /dev directory containing a special file for all devices to be used by the system is mandatory for any Linux system.
The directory itself is a normal directory, and can be created with mkdir in the normal way. The device special files,
however, must be created in a special way, using the mknod command.

There is a shortcut, though — copy devices files from your existing hard disk /dev directory. The only requirement is
that you copy the device special files using -R option. This will copy the directory without attempting to copy the contents
of the files. Be sure to use an upper case R. For example: 

    cp -dpR /dev/fd[01]* /mnt/dev
    cp -dpR /dev/tty[0-6] /mnt/dev


assuming that the diskette is mounted at /mnt. The dp switches ensure that symbolic links are copied as links, rather
than using the target file, and that the original file attributes are preserved, thus preserving ownership information.

If you want to do it the hard way, use ls -l to display the major and minor device numbers for the devices you want,
and create them on the diskette using mknod.

However the devices files are created, check that any special devices you need have been placed on the rescue diskette.
For example, ftape uses tape devices, so you will need to copy all of these if you intend to access your floppy tape drive
from the bootdisk.

Note that one inode is required for each device special file, and inodes can at times be a scarce resource, especially on
diskette filesystems. You'll need to be selective about the device files you include. For example, if you do not have SCSI
disks you can safely ignore /dev/sd*; if you don't intend to use serial ports you can ignore /dev/ttyS*.

If, in building your root filesystem, you get the error No space left on device but a df command shows space still available,
you have probably run out of inodes. A df -i will display inode usage.

Important:   Be sure to include the following files from this directory: console, kmem, mem, null, ram0 and tty1.


4.3.2. /etc

The /etc directory contains configuration files. What it should contain depends on what programs you intend to run. On most
systems, these can be divided into three groups:

    Required at all times, e.g. rc, fstab, passwd.

    May be required, but no one is too sure.

    Junk that crept in. 

Files which are not essential can usually be identified with the command: 

    ls -ltru

This lists files in reverse order of date last accessed, so if any files are not being accessed, they can be omitted from
a root diskette. On my root diskettes, I have the number of config files down to 15. This reduces my work to dealing with
three sets of files:

    The ones I must configure for a boot/root system:

        rc.d/* -- system startup and run level change scripts

        fstab -- list of file systems to be mounted

        inittab -- parameters for the init process, the first process started at boot time.

        gettydefs -- parameters for the init process, the first process started at boot time.

    The ones I should tidy up for a boot/root system:

        passwd -- Critical list of users, home directories, etc.

        group -- user groups.

        shadow -- passwords of users. You may not have this.

        termcap -- the terminal capability database.

If security is important, passwd and shadow should be pruned to avoid copying user passwords off the system, and so that
unwanted logins are rejected when you boot from diskette. Be sure that passwd contains at least root. If you intend other
 users to login, be sure their home directories and shells exist. termcap, the terminal database, is typically several
hundred kilobytes. The version on your boot/root diskette should be pruned down to contain only the terminal(s) you use,
which is usually just the linux or linux-console entry. The rest. They work at the moment, so I leave them alone.

Out of this, I only really have to configure two files, and what they should contain is surprisingly small. 

rc should contain:

        #!/bin/sh       
        /bin/mount -av
        /bin/hostname Kangaroo

Be sure it is executable, be sure it has a "#!" line at the top, and be sure any absolute filenames are correct.
You don't really need to run hostname — it just looks nicer if you do.

fstab should contain at least:

        /dev/ram0       /               ext2    defaults
        /dev/fd0        /               ext2    defaults
        /proc           /proc           proc    defaults


You can copy entries from your existing fstab, but you should not automatically mount any of your hard disk partitions;
use the noauto keyword with them. Your hard disk may be damaged or dead when the bootdisk is used.

Your inittab should be changed so that its sysinit line runs rc or whatever basic boot script will be used.
Also, if you want to ensure that users on serial ports cannot login, comment out all the entries for getty which include
a ttys or ttyS device at the end of the line. Leave in the tty ports so that you can login at the console.

A minimal inittab file looks like this:

        id:2:initdefault:
        si::sysinit:/etc/rc
        1:2345:respawn:/sbin/getty 9600 tty1
        2:23:respawn:/sbin/getty 9600 tty2

The inittab file defines what the system will run in various states including startup, move to multi-user mode, etc.
Check carefully the filenames mentioned in inittab; if init cannot find the program mentioned the bootdisk will hang,
and you may not even get an error message.

Note that some programs cannot be moved elsewhere because other programs have hardcoded their locations. For example,
on my system, /etc/shutdown has hardcoded in it /etc/reboot. If I move reboot to /bin/reboot, and then issue a shutdown
command, it will fail because it cannot find the reboot file.

For the rest, just copy all the text files in your /etc directory, plus all the executables in your /etc directory that
you cannot be sure you do not need. As a guide, consult the sample listing in Appendix C. Probably it will suffice to copy
only those files, but systems differ a great deal, so you cannot be sure that the same set of files on your system is equivalent
to the files in the list. The only sure method is to start with inittab and work out what is required.

Most systems now use an /etc/rc.d/ directory containing shell scripts for different run levels. The minimum is a single rc script,
but it may be simpler just to copy inittab and the /etc/rc.d directory from your existing system, and prune the shell scripts in
the rc.d directory to remove processing not relevent to a diskette system environment.


4.3.3. /bin and /sbin

The /bin directory is a convenient place for extra utilities you need to perform basic operations, utilities such as ls, mv,
cat and dd. See Appendix C for an example list of files that go in a /bin and /sbin directories. It does not include any of
the utilities required to restore from backup, such as cpio, tar and gzip. That is because I place these on a separate utility
diskette, to save space on the boot/root diskette. Once the boot/root diskette is booted, it is copied to the ramdisk leaving
the diskette drive free to mount another diskette, the utility diskette. I usually mount this as /usr.

Creation of a utility diskette is described below in Section 9.2. It is probably desirable to maintain a copy of the same version
of backup utilities used to write the backups so you don't waste time trying to install versions that cannot read your backup tapes.

Important:   Be sure to include the following programs: init, getty or equivalent, login, mount, some shell capable of running
your rc scripts, a link from sh to the shell.


4.3.4. /lib
In /lib you place necessary shared libraries and loaders. If the necessary libraries are not found in your /lib directory then the
system will be unable to boot. If you're lucky you may see an error message telling you why.

Nearly every program requires at least the libc library, libc.so.N, where N is the current version number. Check your /lib directory.
The file libc.so.N is usually a symlink to a filename with a complete version number:

% ls -l /lib/libc*
-rwxr-xr-x   1 root     root      4016683 Apr 16 18:48 libc-2.1.1.so*
lrwxrwxrwx   1 root     root           13 Apr 10 12:25 libc.so.6 -> libc-2.1.1.so*

In this case, you want libc-2.1.1.so. To find other libraries you should go through all the binaries you plan to include and check
their dependencies with ldd. For example:

        % ldd /sbin/mke2fs
        libext2fs.so.2 => /lib/libext2fs.so.2 (0x40014000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0x40026000)
        libuuid.so.1 => /lib/libuuid.so.1 (0x40028000)
        libc.so.6 => /lib/libc.so.6 (0x4002c000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)

Each file on the right-hand side is required. The file may be a symbolic link.

Note that some libraries are quite large and will not fit easily on your root filesystem. For example, the libc.so listed above is
about 4 meg. You will probably need to strip libraries when copying them to your root filesystem. See Section 8 for instructions.

In /lib you must also include a loader for the libraries. The loader will be either ld.so (for A.OUT libraries, which are no longer
common) or ld-linux.so (for ELF libraries). Newer versions of ldd tell you exactly which loader is needed, as in the example above,
but older versions may not. If you're unsure which you need, run the file command on the library. For example:

% file /lib/libc.so.4.7.2 /lib/libc.so.5.4.33 /lib/libc-2.1.1.so
/lib/libc.so.4.7.2: Linux/i386 demand-paged executable (QMAGIC), stripped
/lib/libc.so.5.4.33: ELF 32-bit LSB shared object, Intel 80386, version 1, stripped
/lib/libc-2.1.1.so: ELF 32-bit LSB shared object, Intel 80386, version 1, not stripped

The QMAGIC indicates that 4.7.2 is for A.OUT libraries, and ELF indicates that 5.4.33 and 2.1.1 are for ELF.

Copy the specific loader(s) you need to the root filesystem you're building. Libraries and loaders should be checked carefully against
the included binaries. If the kernel cannot load a necessary library, the kernel may hang with no error message.


4.6. Some final details
Some system programs, such as login, complain if the file /var/run/utmp and the directory /var/log do not exist. So:

        mkdir -p /mnt/var/{log,run}
        touch /mnt/var/run/utmp

Finally, after you have set up all the libraries you need, run ldconfig to remake /etc/ld.so.cache on the root filesystem.
The cache tells the loader where to find the libraries. You can do this with:

        ldconfig -r /mnt

4.7. Wrapping it up

When you have finished constructing the root filesystem, unmount it, copy it to a file and compress it:

        umount /mnt
        dd if=DEVICE bs=1k | gzip -v9 > rootfs.gz

When this finishes you will have a file rootfs.gz. This is your compressed root filesystem. You should check its size to
make sure it will fit on a diskette; if it doesn't you'll have to go back and remove some files. Some suggestions for
reducing root filesystem size appear in Section 8.

Notes [1]  The directory structure presented here is for root diskette use only. Real Linux systems have a more complex
and disciplined set of policies, called the Filesystem Hierarchy Standard, for determining where files should go.)






























